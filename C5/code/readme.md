3. 由程序运行结果来看，用第一组升序的数据建立的BST上查找成功的平ASL为512.5,查找失败的平ASL约为514.5。查找成功的平ASL正好是$\frac {n+1}2$，其中n为1024，是数据条数。由于查找失败的测试数据是用所有小于2048的偶数，所有如果查找失败的平均次数会比查找成功多两次。因此，实验结果和理论分析是符合的。用第二组升序的数据建立的BST上查找成功的平ASL约为12.26,查找失败的平ASL约为14.25.查找成功的平ASL约为$\log_2{1024}+2$，这近似是完全二叉树的深度，由于随机数不一定正好能被组织成完全二叉树，所以平ASL略大于完全二叉树深度。而理论分析可知在完全二叉树上的平ASL为$ASL\approx \log_2{(n+1)}-1$。同样的，查找失败的ASL会多2次。
4. 由程序运行结果来看，在第一组数据上，折半查找的ASL为：成功时约9.0，失败时约10.0。在第二组数据上有完全一致的结果。查找成功的ASL为$ASL\approx \frac {n+1} n \log_2{(n+1)}-1$,查找失败的ASL为$\lfloor \log_2 n \rfloor+1$。由于算法的原因，程序在计算查找失败的ASL时没算最后一次，因此这个结果也是和理论完成吻合的。小数点后多的一点点是因为判定树11层有唯一一个顶点。
5. 以上实验可以说明就平均性能而言，BST的查找与折半查找差不多。原因如下：
+ 极限情况下，BST是完全二叉树，与折半查找性能一致
+ 即使BST不是完全二叉树，一般情况下也不会比完全二叉树多太多层（实验证实了这一点），因此平均性能仍然接近折半查找
+ 即使不幸的是处理的数据有较强的次序，也可以在O(n)内将待插入数据打乱，以获得接近平均性能的BST。